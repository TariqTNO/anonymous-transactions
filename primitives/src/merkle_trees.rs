//! Implementation of the Merkle trees used in the protocol
//! (adaptation of merkle_tree.rs in `zcash_primitives`)

use std::collections::VecDeque;
use std::io::{Read, Write};
use std::iter;

use bls12_381::Scalar;
use ff::{Field, PrimeField};
use rand::Rng;

use crate::constants::{CREDENTIAL_MT_DEPTH, MEMORY_MT_DEPTH, NOTE_MT_DEPTH};
use crate::crhs::{memory_leaf_hash, merkle_tree_hash, note_leaf_hash};
use crate::definitions::{
    CredentialCommitment, MemoryCommitment, MerkleRoot, MerkleWitness, NoteCommitment,
    TransactionTime,
};
use crate::serialise::{
    u128_to_u8_vector, u64_array_to_u8_vector, u8_array_to_u128, u8_array_to_u64,
};

#[derive(Copy, Clone, PartialEq, Debug)]
#[repr(u8)]
/// Enum defining the type of the tree
pub enum TreeType {
    Credential = 0,
    Note = 1,
    Memory = 2,
}

/// Node in a Merkle tree.
#[derive(Copy, Clone)]
pub struct MerkleNode {
    pub value: <Scalar as PrimeField>::Repr,
}

/// Helper class for filling gaps in paths and completing trees
struct PathFiller {
    queue: VecDeque<MerkleNode>,
}

/// General Merkle Tree construction, that works on any node that implements the `MerkleNode` trait.
pub struct MerkleTree {
    tree_type: TreeType,
    depth: usize,
    last_filled_position: u128,
    left: Option<MerkleNode>,
    right: Option<MerkleNode>,
    parents: Vec<Option<MerkleNode>>,
    empty_nodes: Vec<MerkleNode>,
}

impl Clone for MerkleTree {
    fn clone(&self) -> Self {
        MerkleTree {
            tree_type: self.tree_type,
            depth: self.depth,
            last_filled_position: self.last_filled_position,
            left: self.left,
            right: self.right,
            parents: self.parents.clone(),
            empty_nodes: self.empty_nodes.clone(),
        }
    }
}

/// All functionality that is required for computing a witness to the most recently added commitment
/// in a Merkle Tree. It also tracks the updates to the witness if new commitments get added to the
/// underlying tree.
pub struct IncrementalMerkleWitness {
    tree: MerkleTree,
    filled_subtree_roots: Vec<MerkleNode>,
    current_subtree_depth: usize,
    current_subtree: Option<MerkleTree>,
}

impl MerkleNode {
    /// Write a node to a writer.
    pub fn write<W: Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(self.value.as_ref())
    }

    /// Read a node from a reader.
    pub fn read<R: Read>(mut reader: R) -> std::io::Result<MerkleNode> {
        let mut value = Scalar::zero().to_repr();
        reader.read_exact(&mut value)?;
        Ok(MerkleNode { value })
    }

    /// Compute the parent node of this node in this tree
    fn combine(tree_type: TreeType, depth: usize, left: &Self, right: &Self) -> Self {
        Self {
            value: merkle_tree_hash(tree_type, depth, &left.value, &right.value),
        }
    }

    /// Get a blank leaf node (which is equal to one, since that is the smallest point not on the
    /// JubJub curve.)
    fn blank_leaf() -> Self {
        Self {
            value: Scalar::one().to_repr(),
        }
    }

    /// Convert `path` to they type `Vec<(FrRepr, bool)>`
    fn path_convert(path: Vec<(Self, bool)>) -> Vec<(Scalar, bool)> {
        path.iter()
            .map(|(node, b)| {
                (
                    Scalar::from_repr(node.value)
                        .expect("Tree nodes should be in the prime field."),
                    *b,
                )
            })
            .collect::<Vec<_>>()
    }
}

/// Implementation of `MerkleWitness` that allows for creating it from a `IncrementalMerkleWitness`
impl MerkleWitness {
    /// Create a `MerkleWitness` from a witness generated by `IncrementalMerkleWitness`, the boolean
    /// represents whether current leaf (so the neighbour of the witness) is on the right side.
    fn from_incremental_witness(path: Vec<(MerkleNode, bool)>, position: u128) -> Self {
        Self {
            path: MerkleNode::path_convert(path),
            position,
        }
    }

    /// Create a `MerkleWitness` with a path filled with empty nodes and position 0.
    pub fn empty(depth: usize) -> Self {
        Self {
            path: vec![(Scalar::one(), false); depth],
            position: 0,
        }
    }
}

impl PathFiller {
    /// Construct an empty `PathFiller`
    fn empty() -> Self {
        PathFiller {
            queue: VecDeque::new(),
        }
    }

    /// Pop the first element from the queue
    fn next(&mut self, depth: usize, tree: &MerkleTree) -> MerkleNode {
        self.queue
            .pop_front()
            .unwrap_or_else(|| tree.empty_node(depth))
    }
}

impl MerkleTree {
    /// Construct the Credential Merkle Tree.
    pub fn new_cred() -> MerkleTree {
        MerkleTree::new(TreeType::Credential, CREDENTIAL_MT_DEPTH)
    }

    /// Construct the Note Note Merkle Tree.
    pub fn new_note() -> MerkleTree {
        MerkleTree::new(TreeType::Note, NOTE_MT_DEPTH)
    }

    /// Construct the Memory Merkle Tree.
    pub fn new_mem() -> MerkleTree {
        MerkleTree::new(TreeType::Memory, MEMORY_MT_DEPTH)
    }

    /// Append a credential commitment to the Merkle Tree `self`.
    pub fn append_credential_commitment(
        &mut self,
        cm: CredentialCommitment,
    ) -> Result<MerkleNode, ()> {
        assert_eq!(self.tree_type, TreeType::Credential);
        let node = MerkleNode {
            value: cm.to_repr(),
        };
        self.append(node)?;
        Ok(node)
    }

    /// Append a note commitment to the Merkle Tree `self`.
    pub fn append_note_commitment(
        &mut self,
        cm: NoteCommitment,
        t: &TransactionTime,
    ) -> Result<MerkleNode, ()> {
        assert_eq!(self.tree_type, TreeType::Note);
        let node = MerkleNode {
            value: note_leaf_hash(cm, t).to_repr(),
        };
        self.append(node)?;
        Ok(node)
    }

    /// Append a memory commitment to the Merkle Tree `self`.
    pub fn append_memory_commitment(
        &mut self,
        cm: MemoryCommitment,
        t: &TransactionTime,
    ) -> Result<MerkleNode, ()> {
        assert_eq!(self.tree_type, TreeType::Memory);
        let node = MerkleNode {
            value: memory_leaf_hash(cm, t).to_repr(),
        };
        self.append(node)?;
        Ok(node)
    }

    /// Append a random commitment to the Merkle Tree `self`.
    /// The commitment is not necessarily a `valid' commitment.
    pub fn append_random_commitment<R: Rng>(&mut self, rng: &mut R) -> Result<MerkleNode, ()> {
        let node = MerkleNode {
            value: Scalar::random(rng).to_repr(),
        };
        self.append(node)?;
        Ok(node)
    }

    /// Append a random amount in range [low, high) of random commitments to the Merkle Tree `self`.
    pub fn append_random_commitment_range<R: Rng>(
        &mut self,
        rng: &mut R,
        low: u128,
        high: u128,
    ) -> Result<(), ()> {
        for _ in 0..rng.gen_range(low..high) {
            self.append_random_commitment(rng)?;
        }
        Ok(())
    }
}

impl MerkleTree {
    /// Create an empty tree of `depth` (1 <= `depth` <= 128).
    pub fn new(tree_type: TreeType, depth: usize) -> Self {
        assert!((1..=128).contains(&depth));
        let mut empty_nodes = vec![MerkleNode::blank_leaf()];
        for prev in 0..(depth - 1) {
            empty_nodes.push(MerkleNode::combine(
                tree_type,
                prev,
                &empty_nodes[prev],
                &empty_nodes[prev],
            ))
        }
        Self {
            tree_type,
            depth,
            last_filled_position: 0,
            left: None,
            right: None,
            parents: vec![],
            empty_nodes,
        }
    }

    /// Write a MerkleTree to a writer.
    pub fn write<W: Write>(&self, mut writer: W) -> std::io::Result<()> {
        writer.write_all(&u128_to_u8_vector(self.last_filled_position))?;
        match self.left {
            None => writer.write_all(&[0])?,
            Some(node) => {
                writer.write_all(&[1])?;
                node.write(writer.by_ref())?;
            }
        }
        match self.right {
            None => writer.write_all(&[0])?,
            Some(node) => {
                writer.write_all(&[1])?;
                node.write(writer.by_ref())?;
            }
        }
        writer.write_all(&u64_array_to_u8_vector(&[self.parents.len() as u64]))?;
        for parent in &self.parents {
            match parent {
                None => writer.write_all(&[0])?,
                Some(node) => {
                    writer.write_all(&[1])?;
                    node.write(writer.by_ref())?;
                }
            }
        }
        Ok(())
    }

    /// Read a MerkleTree from a reader.
    pub fn read<R: Read>(
        mut reader: R,
        tree_type: TreeType,
        depth: usize,
    ) -> std::io::Result<MerkleTree> {
        let mut tree = MerkleTree::new(tree_type, depth);
        let mut last_filled_position = [0; 16];
        reader.read_exact(&mut last_filled_position)?;
        tree.last_filled_position = u8_array_to_u128(&last_filled_position);
        let mut option = [0; 1];
        reader.read_exact(&mut option)?;
        match option[0] {
            0 => tree.left = None,
            1 => tree.left = Some(MerkleNode::read(reader.by_ref())?),
            _ => {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    "Cannot read tree.",
                ));
            }
        }
        reader.read_exact(&mut option)?;
        match option[0] {
            0 => tree.right = None,
            1 => tree.right = Some(MerkleNode::read(reader.by_ref())?),
            _ => {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    "Cannot read tree.",
                ));
            }
        }
        let mut parent_amount = [0; 8];
        reader.read_exact(&mut parent_amount)?;
        let parent_amount = u8_array_to_u64(&parent_amount);
        for _ in 0..parent_amount {
            reader.read_exact(&mut option)?;
            match option[0] {
                0 => tree.parents.push(None),
                1 => tree.parents.push(Some(MerkleNode::read(reader.by_ref())?)),
                _ => {
                    return Err(std::io::Error::new(
                        std::io::ErrorKind::Other,
                        "Cannot read tree.",
                    ));
                }
            }
        }
        Ok(tree)
    }

    /// Obtain an empty node at the given `depth`
    pub fn empty_node(&self, depth: usize) -> MerkleNode {
        assert!(depth <= self.depth);

        self.empty_nodes[depth]
    }

    /// Returns boolean value telling if the tree is full or not
    fn is_full(&self) -> bool {
        self.last_filled_position.count_ones() as usize == self.depth
    }

    /// Append a leaf node to the tree, or return error if tree is full
    pub fn append(&mut self, node: MerkleNode) -> Result<(), ()> {
        if self.is_full() {
            return Err(());
        }

        match (self.left, self.right) {
            (None, _) => self.left = Some(node),
            (_, None) => self.right = Some(node),
            (Some(left), Some(right)) => {
                let mut parent = MerkleNode::combine(self.tree_type, 0, &left, &right);
                self.left = Some(node);
                self.right = None;

                for i in 0..self.depth {
                    if i < self.parents.len() {
                        if let Some(old_parent) = self.parents[i] {
                            parent =
                                MerkleNode::combine(self.tree_type, i + 1, &old_parent, &parent);
                            self.parents[i] = None;
                        } else {
                            self.parents[i] = Some(parent);
                            break;
                        }
                    } else {
                        self.parents.push(Some(parent));
                        break;
                    }
                }
            }
        }
        if self.last_filled_position != 0 || self.right.is_some() {
            self.last_filled_position += 1;
        }

        Ok(())
    }

    /// Return the value of the current root of the Merkle Tree
    pub fn root_value(&self) -> MerkleRoot {
        Scalar::from_repr(self.root().value).expect("Tree nodes should be in the prime field.")
    }

    /// Return the current root of the Merkle Tree
    fn root(&self) -> MerkleNode {
        self.root_with_filler(PathFiller::empty())
    }

    /// Return the current root of the Merkle Tree, uses `filler` to fill gaps
    fn root_with_filler(&self, mut filler: PathFiller) -> MerkleNode {
        // Compute leaf root (at depth 1)
        let mut root = MerkleNode::combine(
            self.tree_type,
            0,
            &self.left.unwrap_or_else(|| filler.next(0, self)),
            &self.right.unwrap_or_else(|| filler.next(0, self)),
        );

        // Update root till currently-filled depth.
        root = self
            .parents
            .iter()
            .zip(1..)
            .fold(root, |root_cur, (parent, i)| match parent {
                Some(p) => MerkleNode::combine(self.tree_type, i, p, &root_cur),
                None => MerkleNode::combine(self.tree_type, i, &root_cur, &filler.next(i, self)),
            });

        // Update root till top
        ((self.parents.len() + 1)..self.depth).fold(root, |root_cur, i| {
            MerkleNode::combine(self.tree_type, i, &root_cur, &filler.next(i, self))
        })
    }
}

impl IncrementalMerkleWitness {
    /// Create a `MerkleWitness` for the most recent commitment to the input Merkle Tree `tree`
    pub fn from_tree(tree: &MerkleTree) -> IncrementalMerkleWitness {
        assert!(tree.last_filled_position != 0 || tree.left.is_some());
        IncrementalMerkleWitness {
            tree: tree.clone(),
            filled_subtree_roots: vec![],
            current_subtree_depth: 0,
            current_subtree: None,
        }
    }

    /// Write an IncrementalMerkleWitness to a writer.
    pub fn write<W: Write>(&self, mut writer: W) -> std::io::Result<()> {
        self.tree.write(writer.by_ref())?;
        writer.write_all(&u64_array_to_u8_vector(&[
            self.filled_subtree_roots.len() as u64
        ]))?;
        for subtree_root in &self.filled_subtree_roots {
            subtree_root.write(writer.by_ref())?;
        }
        writer.write_all(&u64_array_to_u8_vector(
            &[self.current_subtree_depth as u64],
        ))?;
        match &self.current_subtree {
            None => writer.write_all(&[0])?,
            Some(subtree) => {
                writer.write_all(&[1])?;
                subtree.write(writer.by_ref())?;
            }
        }
        Ok(())
    }

    pub fn read<R: Read>(
        mut reader: R,
        tree_type: TreeType,
        depth: usize,
    ) -> std::io::Result<IncrementalMerkleWitness> {
        let tree = MerkleTree::read(reader.by_ref(), tree_type, depth)?;
        let mut subtree_root_amount = [0; 8];
        reader.read_exact(&mut subtree_root_amount)?;
        let subtree_root_amount = u8_array_to_u64(&subtree_root_amount);
        let mut filled_subtree_roots = vec![];
        for _ in 0..subtree_root_amount {
            filled_subtree_roots.push(MerkleNode::read(reader.by_ref())?);
        }
        let mut current_subtree_depth = [0; 8];
        reader.read_exact(&mut current_subtree_depth)?;
        let current_subtree_depth = u8_array_to_u64(&current_subtree_depth) as usize;
        let mut option = [0; 1];
        reader.read_exact(&mut option)?;
        let current_subtree = match option[0] {
            0 => None,
            1 => Some(MerkleTree::read(
                reader.by_ref(),
                tree_type,
                current_subtree_depth,
            )?),
            _ => {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    "Cannot read tree.",
                ))
            }
        };
        Ok(IncrementalMerkleWitness {
            tree,
            filled_subtree_roots,
            current_subtree_depth,
            current_subtree,
        })
    }

    /// Get the position of the most recently added node to the underlying tree
    fn position(&self) -> u128 {
        self.tree.last_filled_position
    }

    /// Helper function for computing the filler that fills gaps and completing trees
    fn filler(&self) -> PathFiller {
        PathFiller {
            queue: match &self.current_subtree {
                Some(subtree) => self
                    .filled_subtree_roots
                    .iter()
                    .cloned()
                    .chain(iter::once(subtree.root()))
                    .collect(),
                None => self.filled_subtree_roots.iter().cloned().collect(),
            },
        }
    }

    /// Helper function for finding the next depth of an unfilled subtree.
    fn next_empty_depth(&self) -> usize {
        let mut skip = self.filled_subtree_roots.len();

        if self.tree.left.is_none() {
            if skip == 0 {
                return 0;
            }
            skip -= 1;
        }

        if self.tree.right.is_none() {
            if skip == 0 {
                return 0;
            }
            skip -= 1;
        }

        let mut depth = 1;
        for p in &self.tree.parents {
            if p.is_none() {
                if skip == 0 {
                    return depth;
                }
                skip -= 1;
            }
            depth += 1;
        }

        depth + skip
    }

    pub fn append(&mut self, node: MerkleNode) -> Result<(), ()> {
        match self.current_subtree.take() {
            Some(mut subtree) => {
                subtree
                    .append(node)
                    .expect("Subtree cannot be full at this point");
                if subtree.is_full() {
                    self.filled_subtree_roots.push(subtree.root())
                } else {
                    self.current_subtree = Some(subtree);
                }
            }
            None => {
                self.current_subtree_depth = self.next_empty_depth();

                // Throw error if underlying tree is full
                if self.current_subtree_depth >= self.tree.depth {
                    return Err(());
                }

                if self.current_subtree_depth == 0 {
                    self.filled_subtree_roots.push(node);
                } else {
                    let mut new_subtree =
                        MerkleTree::new(self.tree.tree_type, self.current_subtree_depth);
                    new_subtree
                        .append(node)
                        .expect("Subtree cannot be full at this point");
                    self.current_subtree = Some(new_subtree);
                }
            }
        }

        Ok(())
    }

    /// Return the value of the current root of the `tree`, taking later additions into account
    pub fn root_value(&self) -> MerkleRoot {
        Scalar::from_repr(self.tree.root_with_filler(self.filler()).value)
            .expect("Tree nodes should be in the prime field.")
    }

    /// Compute the witness to the most recently added commitment to `tree`, taking later additions
    /// into account
    pub fn witness(&self) -> MerkleWitness {
        let mut filler = self.filler();
        let mut path = vec![];

        // Obtain leaf witness
        match (self.tree.left, self.tree.right) {
            (Some(witness), Some(_)) => path.push((witness, true)),
            (Some(_), _) => path.push((filler.next(0, &self.tree), false)),
            _ => unreachable!(),
        }

        // Update path till depth that is filled in the underlying tree
        for (parent, i) in self.tree.parents.iter().zip(1..) {
            path.push(match parent {
                Some(p) => (*p, true),
                None => (filler.next(i, &self.tree), false),
            });
        }

        // Update path till the root is found
        for i in (self.tree.parents.len() + 1)..self.tree.depth {
            path.push((filler.next(i, &self.tree), false));
        }

        MerkleWitness::from_incremental_witness(path, self.position())
    }
}
